# Содержание:

---
## Модуль `Auth`

---

### Структуры:

---
- [Структуры модели User](#user-structure)

---
### Варианты использования:

---
- [Регистрация c подтверждением email](#sign-up)
- [Аутентификация](#sign-in)
- [Запрос на сброс пароля](#access-recovery)
- [Обновление пароля](#password-udate)
- [Запрос на обновление email. Обновление email](#email-udate)
- [Получение информации о пользователе](#get-user)
- [Получение списка пользователей](#get-user-list)


---
## Модуль `Blog`

---

### Структуры:

---
- [Структуры модели Reader](#reader-structure)
- [Структуры модели Post](#post-structure)
- [Структуры модели Category](#post-category-structure)
- [Структуры модели Comment](#post-comment-structure)
- [Структуры модели Tag](#post-tag-structure)
- [Структуры модели FileStorage](#file-storage)

---
### Варианты использования:

---
- [Создание читателя](#create-blog-reader)
- [Получение информации о читателе](#get-blog-reader)
- [Создание категории поста](#create-blog-category)
- [Получение списка категорий](#get-blog-category-list)
- [Получение категории](#get-blog-category)
- [Создание тега поста](#create-post-tag)
- [Получение списка тегов](#get-blog-tag-list)
- [Создание поста](#create-blog-post)
- [Получение списка постов](#get-blog-posts)
- [Получение поста](#get-blog-post)

<br>
<br>
<br>

### Структуры модели User <a name="user-structure"></a>

`User`

|    Название колонки    |     Тип      | nullable |             Назначение              |
|:----------------------:|:------------:|:--------:|:-----------------------------------:|
|           id           |     UUID     |   нет    |     Идентификатор пользователя      |
|       first_name       | varchar(255) |   нет    |                 Имя                 |
|       last_name        | varchar(255) |    да    |               Фамилия               |
|         email          | varchar(255) |   нет    |                Почта                |
|  email_confirm_token   | varchar(255) |    да    |   Подтвержение корректности email   |
|         status         | varchar(255) |   нет    |         Статус пользователя         |
|          role          | varchar(255) |   нет    |          Роль пользователя          |
|     password_hash      | varchar(255) |   нет    |             Хэш пароля              |
|          host          | varchar(100) |    да    |     Хост-источник пользователя      |
|  reset_password_token  | varchar(255) |    да    |         Токен сброса пароля         |
| password_token_expires |  timestamp   |    да    | Время действия токена сброса пароля |
|       new_email        | varchar(255) |    да    |             Новый email             |
|       created_at       |  timestamp   |   нет    |            Дата создания            |



### Регистрация c подтверждением email <a name="sign-up"></a>

**Бизнес смысл**

Регистрация представляет собой страницу sign page для входа в систему. Данная страница состоит запроса регистрации пользования со следующими полями: имя, email, пароль

**Доступ**

Любой посетитель

**Входные данные**

|   Название поля    | Обязательность |             Примечание              |
|:------------------:|:--------------:|:-----------------------------------:|
|     firstName      |       да       | Валидация текста (min/max и прочее) |
|       email        |       да       |           Валидация email           |
|      password      |       да       |          Валидация пароля           |
| registrationSource |       да       |        Источник регистрации         |

**Логика обработки данных запроса**

1. Создать пользователя со статусом wait и с ролью ROLE_USER и проверкой возможных инвариантов. При создании пользователя формируется доменное событие UserCreatedEvent со следующими полями:  
    <br>
    - id
    - firstName
    - lastName
    - email
    - emailConfirmToken
    - status
    - role
    - registrationSource
    - createdAt  
    <br>  
2. Создать слушатель события UserCreatedEvent который отправит пользователю на указанный email письмо с подтверждением аккаунта (email), где в качестве query string будет указан email_confirm_token и id пользователя.  
<br>
   - Ссылка подтверждения email пользователя формируется с учетом содержимого registrationSource. На текущий момент registrationSource может принимать два значения - blog, shop, которым в модуле Auth соответствуют реальные доменные имена (domain) заданные через переменные окружения (.env...). В результате ссылка для регистрации формируется следующим образом н-р - **https:/<domain>/confirm-email?userId=<id>&token=<token>**  
<br>
3. При переходе по ссылке из письма статус пользователя меняет статус на active. Поле email_confirm_token обнуляется. С этого момента система считает пользователя авторизованным.
4. После добавления пользователя бросается событие 

`*email_confirm_token - можно получить с использованием UUID`  
`*возможные статусы пользователя: blocked, active, wait`  
`*возможные роли пользователя: ROLE_USER, ROLE_ADMIN`  



### Получение списка пользователей <a name="get-user-list"></a>

**Бизнес смысл**

Получение списка пользователей зарегистрированных в сервисе

**Доступ**

ROLE_ADMIN

**Входные данные**

|   Название поля    | Обязательность |             Примечание              |
|:------------------:|:--------------:|:-----------------------------------:|
|       limit        |       да       |  Валидация int (min/max и прочее)   |
|       offset       |       да       |  Валидация int (min/max и прочее)   |
|     firstName      |      нет       | Валидация текста (min/max и прочее) |
|      LastName      |      нет       | Валидация текста (min/max и прочее) |
|       email        |      нет       | Валидация текста (min/max и прочее) |
|       status       |      нет       |           Валидация email           |
|        role        |      нет       |          Валидация пароля           |

`*Поле limit не может привышать 100 элементов`

**Структура ответа**

```
data:
-- id: 1
-- attributes:
---- attr1:
---- attr2:
---- ...
-- relationships: 
---- relation-name1: 
------ attr-relation1:
------ attr-relation2:
------ ...
---- relation-name2: 
------ attr-relation1:
------ attr-relation2:
------ ...
meta: 
-- offset:
-- limit:
-- total:
```

**Логика обработки данных запроса**

1. Валидация входных данных.
2. Сходить в базу данных и сделать выборку по пользователям с учетом фильтра сформированного из входных данных. Необязательные поля игнорируются при выборке
3. Запрос необходимо делать через специальный фетчер (возможно разделение Read/Write)



### Получение информации о пользователе <a name="get-user"></a>

**Бизнес смысл**

Вывод информации о пользователе

**Доступ**

ROLE_ADMIN

**Входные данные**

| Название поля | Обязательность |    Примечание     |
|:-------------:|:--------------:|:-----------------:|
|      id       |       да       |  из query string  |

**Логика обработки данных запроса**

**Структура ответа**

```
data:
-- id: 1
-- attributes:
---- attr1:
---- attr2:
---- ...
-- relationships: 
---- relation-name1: 
------ attr-relation1:
------ attr-relation2:
------ ...
---- relation-name2: 
------ attr-relation1:
------ attr-relation2:
------ ...
```

1. Получить информацию по пользователю из бд.
   <br>
   - firstName
   - lastName
   - email
   - status
   - role
   - createdAt  
     <br>
2. Сформировать ответ



### Аутентификация <a name="sign-in"></a>

**Бизнес смысл**

Представляет собой страницу для процедуры проверки подлинности пользователя

**Доступ**

PUBLIC_ACCESS

**Входные данные**

| Название поля | Обязательность |             Примечание              |
|:-------------:|:--------------:|:-----------------------------------:|
|     email     |       да       |           Валидация email           |
|   password    |       да       |          Валидация пароля           |

**Логика обработки данных запроса**

1. Настроить security bundle для входа пользователя в админку с сохранением ID сессии в cookie заголовках
2. После аутентификации пользователь должен попасть в админку сервиса



### Запрос на сброс пароля<a name="access-recovery"></a>

**Бизнес смысл**

Процесс обновления пароля в системе

**Доступ**

PUBLIC_ACCESS

**Входные данные**

| Название поля | Обязательность |             Примечание              |
|:-------------:|:--------------:|:-----------------------------------:|
|     email     |       да       |           Валидация email           |

**Логика обработки данных запроса**

1. Заполняем поля reset_password_token (UUID) и password_token_expires.
2. Отправляем пользователю письмо содержащее ссылку на страницу для сброса пароля. Ссылка содержит в query string reset_password_token который "разрешает" данному пользователю сбросить пароль



### Обновление пароля<a name="password-udate"></a>

**Бизнес смысл**

Страница обновления пароля

**Доступ**

PUBLIC_ACCESS

**Входные данные**

|     Название поля      | Обязательность |    Примечание     |
|:----------------------:|:--------------:|:-----------------:|
|  reset_password_token  |       да       |  из query string  |
|        password        |       да       | Валидация пароля  |

**Логика обработки данных запроса**

1. Проверяем соответствует ли reset_password_token тому что в бд, если да переходим далее.
2. Проверяем поле password_token_expires, если password_token_expires < now(), то необходимо бросить исключение - "Срок действия токена для сброса пароля истек, повторите операцию". Обнуляем поля reset_password_token и password_token_expires
3. Обновляем пароль пользователя и через всплывашку указываем пользователю сообщение о том, что операция прошла успешно
4. Перенаправляем пользователя на страницу входа в систему



### Запрос на обновление email. Обновление email<a name="email-udate"></a>

`*На данный момент это не является приоритетным функционалом, будет добавлен позднее`



### Структуры модели Reader <a name="reader-structure"></a>

`Reader`

|    Название колонки    |     Тип      | nullable |       Назначение       |
|:----------------------:|:------------:|:--------:|:----------------------:|
|           id           |     UUID     |   нет    | Идентификатор читателя |
|       first_name       | varchar(255) |   нет    |          Имя           |
|       last_name        | varchar(255) |    да    |        Фамилия         |
|         email          | varchar(255) |   нет    |         Почта          |
|       created_at       |  timestampz  |   нет    |     Дата создания      |



### Создание читателя блога <a name="create-blog-reader"></a>

**Бизнес смысл**

На первом этапе читатель блога создается с целью возможности комментировании статей блога

**Доступ**

PUBLIC_ACCESS

**Входные данные**

| Название поля | Обязательность |             Примечание              |
|:-------------:|:--------------:|:-----------------------------------:|
|   firstName   |       да       | Валидация текста (min/max и прочее) |
|   last_name   |       да       | Валидация текста (min/max и прочее) |
|     email     |       да       |           Валидация email           |

**Логика обработки данных запроса**

1. Дополнить текущую реализацию обработки события UserCreatedEvent. Необходимо добавить в директорию Common интерфейс UserCreatedEventInterface
2. UserCreatedEvent заимплементировать от UserCreatedEventInterface тем самым сделав данное событие общим для всех модулей - каждый из модулей может подписаться на это событие, при этом UserCreatedEventInterface будет находится в общем ядре для модулей\
3. Создать объект Reader, сохранить в хранилище. При сохранении проверить необходимые инварианты:
   <br>
   - Поле email уникально
   <br>


### Получение информации о читателе <a name="get-blog-reader"></a>

**Бизнес смысл**

Получение информации о читателе

**Доступ**

ROLE_USER

**Входные данные**

| Название поля | Обязательность |   Примечание    |
|:-------------:|:--------------:|:---------------:|
|    userId     |       да       | Из query string |

**Логика обработки данных запроса**

**Структура ответа**

```
data:
-- id: 1
-- attributes:
---- attr1:
---- attr2:
---- ...
-- relationships: 
---- relation-name1: 
------ attr-relation1:
------ attr-relation2:
------ ...
---- relation-name2: 
------ attr-relation1:
------ attr-relation2:
------ ...
```

1. Валидация входных данных.
2. Сходить в базу данных и сделать выборку пользователя по UUID.
3. Запрос необходимо делать через специальный фетчер (возможно разделение Read/Write)



### Структуры модели Post <a name="post-structure"></a>

`Post`

| Название колонки  |     Тип      | nullable |           Назначение           |
|:-----------------:|:------------:|:--------:|:------------------------------:|
|        id         |     uuid     |   нет    |      Идентификатор поста       |
|       slug        | varchar(100) |   нет    |           slug поста           |
|       title       | varchar(255) |   нет    |           Заголовок            |
|    short_title    | varchar(100) |   нет    |       Короткий заголовок       |
|      content      |     text     |   нет    |       Содержание статьи        |
|      status       | string(enum) |   нет    |       Статус публикации        |
| comment_available |   boolean    |   нет    |    Доступность комментариев    |
|    category_id    |     UUID     |   нет    |        Категория поста         |
|   meta_keyword    | varchar(255) |    да    | Ключевые слова поста (для сео) |
| meta_description  | varchar(255) |    да    |    Описание поста (для сео)    |
|    created_at     |  timestampz  |   нет    |         Дата создания          |


`PostImageLink (составной первичный ключ post_id + file_metadata_key)`

| Название колонки |     Тип     | nullable |                   Назначение                   |
|:----------------:|:-----------:|:--------:|:----------------------------------------------:|
|     post_id      |    uuid     |   нет    |        Идентификатор изображения поста         |
|     file_key     |    uuid     |   нет    |       Идентификатор файлового хранилища        |
|       type       | varchar(50) |   нет    | Тип изображения (main, thumbnail_400, content) |
|    created_at    | timestampz  |   нет    |                 Дата создания                  |


`FileMetadata`

| Название колонки |     Тип      | nullable |           Назначение            |
|:----------------:|:------------:|:--------:|:-------------------------------:|
|       key        |     uuid     |   нет    | Идентификатор файла в хранилище |
|       name       | varchar(255) |   нет    | Оригинальное наименование файла |
|       type       | varchar(50)  |   нет    |     Тип файла (по сущности)     |
|    extension     | varchar(20)  |   нет    |        Расширение файла         |
|    created_at    |  timestampz  |   нет    |          Дата создания          |


### Создание поста <a name="create-blog-post"></a>

**Бизнес смысл**

Пост является ключевым элементом блога. Представляет собой не большую информационную статью относящуюся к какой-то категории (теме)

**Доступ**

ROLE_ADMIN

**Входные данные**

|  Название поля   | Обязательность |                Примечание                |
|:----------------:|:--------------:|:----------------------------------------:|
|      title       |       да       |   Валидация текста (min/max и прочее)    |
|    shortTitle    |       да       |   Валидация текста (min/max и прочее)    |
|     content      |       да       |   Валидация текста (min/max и прочее)    |
|     category     |       да       |   Валидация текста (min/max и прочее)    |
|       tag        |       да       |   Валидация текста (min/max и прочее)    |
|   metaKeyword    |       да       |   Валидация текста (min/max и прочее)    |
| metaDescription  |       да       |   Валидация текста (min/max и прочее)    |
|      image       |       да       | Валидация изображения (min/max и прочее) |
|    published     |      нет       |                Валидация                 |
| commentAvailable |      нет       |                Валидация                 |

**Логика обработки данных запроса**

1. Проверить на уникальность title, если уникально, переходим к следующему пункту
2. Проверить на уникальность shortTitle, если уникально, переходим к следующему пункту
3. Проверить что shortTitle короче title, если да, переходим к следующему пункту
4. Найти способ генерации slug из входящего shortTitle. Поискать библиотеки на эту тему. Сгенерировать слаг при создании экземпляра агрегата поста.
5. Установить связь поста с тегом в агрегате Post
6. Установить связь поста с главным изображением - таблица ImageFileStorageLink.
7. Загрузить главное изображение в файловое хранилище (minio).
   <br>
   - `*Перед созданием поста необходимо поднять файловое хранилище для изображений/документов`
   <br>
8. Если загрузка файла в хранилище прошло успешно сохраняем пост.


### Получение списка постов <a name="get-blog-posts"></a>

**Бизнес смысл**

Получение списка постов блог

**Доступ**

PUBLIC_ACCESS

**Входные данные**

| Название поля | Обязательность |             Примечание              |
|:-------------:|:--------------:|:-----------------------------------:|
|     limit     |       да       |  Валидация int (min/max и прочее)   |
|    offset     |       да       |  Валидация int (min/max и прочее)   |
|     title     |      нет       | Валидация текста (min/max и прочее) |
|  shortTitle   |      нет       | Валидация текста (min/max и прочее) |
|    content    |      нет       | Валидация текста (min/max и прочее) |
|  category_id  |      нет       |            Валидация int            |
|    tag_id     |      нет       |            Валидация int            |
|   published   |      нет       |          Валидация boolean          |

`*Поле limit не может привышать 100 элементов`

**Структура ответа**

```
data:
-- id: 1
-- attributes:
---- attr1:
---- attr2:
---- ...
-- relationships: 
---- relation-name1: 
------ attr-relation1:
------ attr-relation2:
------ ...
---- relation-name2: 
------ attr-relation1:
------ attr-relation2:
------ ...
meta: 
-- offset:
-- limit:
-- total:
```

**Логика обработки данных запроса**

1. Валидация входных данных.
2. Сходить в базу данных и сделать выборку по постам с учетом фильтра сформированного из входных данных. Необязательные поля игнорируются при выборке
3. Забрать следующие данные по посту
   <br>
   - id
   - title
   - short_title
   - published
   - created_at
   - category_id (relationships: category)
   - category_name (relationships: category)
   - tag_id (relationships: tag)
   - tag_name (relationships: tag)
   - imageLink (relationships: fileStorage)
   <br>
4. Запрос необходимо делать через специальный фетчер (возможно разделение Read/Write)


### Получение поста <a name="get-blog-post"></a>

**Бизнес смысл**

Вывод информации по посту

**Доступ**

PUBLIC_ACCESS

**Входные данные**

| Название поля | Обязательность |    Примечание     |
|:-------------:|:--------------:|:-----------------:|
|      id       |       да       |  из query string  |

**Логика обработки данных запроса**

**Структура ответа**

```
data:
-- id: 1
-- attributes:
---- attr1:
---- attr2:
---- ...
-- relationships: 
---- relation-name1: 
------ attr-relation1:
------ attr-relation2:
------ ...
---- relation-name2: 
------ attr-relation1:
------ attr-relation2:
------ ...
```

1. Получить информацию по посту из бд.
   <br>
   - id
   - slug
   - title
   - short_title
   - content
   - published
   - commentAvailable
   - metaKeyword
   - metaDescription
   - created_at
   - category_id (relationships: category)
   - category_name (relationships: category)
   - tag_id (relationships: tag)
   - tag_name (relationships: tag)
   - imageLink (relationships: fileStorage)
   <br>
2. Сформировать ответ


### Структуры модели Category <a name="post-category-structure"></a>

`Category`

| Название колонки |     Тип      | nullable |       Назначение        |
|:----------------:|:------------:|:--------:|:-----------------------:|
|        id        |     UUID     |   нет    | Идентификатор категории |
|       name       | varchar(40)  |   нет    |      Имя категории      |
|   description    | varchar(255) |   нет    |   Описание категории    |
|    created_at    |  timestampz  |   нет    |      Дата создания      |


### Создание категории поста блога <a name="create-blog-category"></a>

**Бизнес смысл**

Каждый пост относится к определенному ограниченному числу категорий

**Доступ**

ROLE_ADMIN

**Входные данные**

| Название поля | Обязательность |                  Примечание                  |
|:-------------:|:--------------:|:--------------------------------------------:|
|     name      |       да       | Имя категории (выводится в списке категорий) |
|  description  |       да       |              Описание категории              |

**Логика обработки данных запроса**

1. Проверить инварианты перед сохранением новой категории в хранилище:  
   <br>
   - Поле name уникально
   <br>
2. Добавить новую категорию


### Получение списка категорий <a name="get-blog-category-list"></a>

**Бизнес смысл**

Получение списка категорий блога

**Доступ**

PUBLIC_ACCESS

**Входные данные**

| Название поля | Обязательность |             Примечание              |
|:-------------:|:--------------:|:-----------------------------------:|
|     limit     |       да       |  Валидация int (min/max и прочее)   |
|    offset     |       да       |  Валидация int (min/max и прочее)   |
|     name      |      нет       | Валидация текста (min/max и прочее) |

`*Поле limit не может привышать 100 элементов`

**Структура ответа**

```
data:
-- id: 1
-- attributes:
---- attr1:
---- attr2:
---- ...
-- relationships: 
---- relation-name1: 
------ attr-relation1:
------ attr-relation2:
------ ...
---- relation-name2: 
------ attr-relation1:
------ attr-relation2:
------ ...
meta: 
-- offset:
-- limit:
-- total:
```

**Логика обработки данных запроса**

1. Валидация входных данных.
2. Сходить в базу данных и сделать выборку по категориям с учетом фильтра сформированного из входных данных. Необязательные поля игнорируются при выборке
3. Запрос необходимо делать через специальный фетчер (возможно разделение Read/Write)


### Получение категории <a name="get-blog-category"></a>

**Бизнес смысл**

Вывод информации о категории

**Доступ**

PUBLIC_ACCESS

**Входные данные**

| Название поля | Обязательность |    Примечание     |
|:-------------:|:--------------:|:-----------------:|
|      id       |       да       |  из query string  |

**Логика обработки данных запроса**

**Структура ответа**

```
data:
-- id: 1
-- attributes:
---- attr1:
---- attr2:
---- ...
-- relationships: 
---- relation-name1: 
------ attr-relation1:
------ attr-relation2:
------ ...
---- relation-name2: 
------ attr-relation1:
------ attr-relation2:
------ ...
```

1. Получить информацию по пользователю из бд.
   <br>
   - name
   - description
   - craetedAt  
   <br>
2. Сформировать ответ


### Структуры модели Comment <a name="post-comment-structure"></a>

`Comment`

| Название колонки |      Тип      | nullable |            Назначение            |
|:----------------:|:-------------:|:--------:|:--------------------------------:|
|        id        |     UUID      |   нет    |    Идентификатор комментария     |
|    parent_id     |     UUID      |    да    |     Родительский комментарий     |
|     post_id      |      int      |   нет    |         Пост комментария         |
|     content      | varchar(1000) |   нет    |      Содержание комментария      |
|    author_id     |     UUID      |   нет    | Идентификатор автора комментария |
|    deleted_at    |  timestampz   |    да    |         Признак удаления         |
|    created_at    |  timestampz   |   нет    |          Дата создания           |




### Структуры модели Tag <a name="post-tag-structure"></a>

`Tag`

| Название колонки |     Тип      | nullable |     Назначение     |
|:----------------:|:------------:|:--------:|:------------------:|
|        id        |     int      |   нет    | Идентификатор тега |
|      label       | varchar(40)  |   нет    |     Метка тега     |
|   description    | varchar(255) |    да    |   Описание тега    |
|    deleted_at    |  timestampz  |    да    |  Признак удаления  |
|    created_at    |  timestampz  |   нет    |   Дата создания    |

`TagPostLink` (реализовать составной первичный ключ)

| Название колонки | Тип | nullable |     Назначение     |
|:----------------:|:---:|:--------:|:------------------:|
|      tag_id      | int |   нет    | Идентификатор тега |
|     post_id      | int |   нет    | Наименование поста |


### Создание тега поста <a name="create-post-tag"></a>

**Бизнес смысл**

Каждый пост должен быть помечен одним из существующих тегов

**Доступ**

ROLE_ADMIN

**Входные данные**

| Название поля | Обязательность |     Примечание     |
|:-------------:|:--------------:|:------------------:|
|     label     |       да       |     Метка тега     |
|  description  |       да       |   Описание тега    |

**Логика обработки данных запроса**

1. Проверить инварианты перед сохранением нового тега в хранилище:  
   <br>
   - Поле label уникально
   <br>
2. Добавить новый тег поста


### Получение списка тегов <a name="get-blog-tag-list"></a>

**Бизнес смысл**

Получение списка тегов поста

**Доступ**

PUBLIC_ACCESS

**Входные данные**

| Название поля | Обязательность |             Примечание              |
|:-------------:|:--------------:|:-----------------------------------:|
|     limit     |       да       |  Валидация int (min/max и прочее)   |
|    offset     |       да       |  Валидация int (min/max и прочее)   |
|     label     |      нет       | Валидация текста (min/max и прочее) |
|    postId     |      нет       | Валидация текста (min/max и прочее) |

`*Поле limit не может привышать 100 элементов`

**Структура ответа**

```
data:
-- id: 1
-- attributes:
---- attr1:
---- attr2:
---- ...
-- relationships: 
---- relation-name1: 
------ attr-relation1:
------ attr-relation2:
------ ...
---- relation-name2: 
------ attr-relation1:
------ attr-relation2:
------ ...
meta: 
-- offset:
-- limit:
-- total:
```

**Логика обработки данных запроса**

1. Валидация входных данных.
2. Сходить в базу данных и сделать выборку по тегам с учетом фильтра сформированного из входных данных. Необязательные поля игнорируются при выборке
3. Запрос необходимо делать через специальный фетчер (возможно разделение Read/Write)


### Структуры модели File Storage <a name="file-storage"></a>

`FileStorage`

| Название колонки |     Тип      | nullable |       Назначение       |
|:----------------:|:------------:|:--------:|:----------------------:|
|        id        |     UUID     |   нет    |     Идентификатор      |
|    file_name     | varchar(255) |   нет    |     Название файла     |
|     file_key     | varchar(100) |   нет    | Ключ файла в хранилище |
|   content_type   | varchar(255) |   нет    | Тип файла (MIME TYPE)  |
|    extension     | varchar(20)  |   нет    |    Расширение файла    |
|    created_at    |  timestampz  |   нет    |     Дата создания      |
